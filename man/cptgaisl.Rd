% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cptgaisl.R
\name{cptgaisl}
\alias{cptgaisl}
\title{Island model based genetic algorithm}
\usage{
cptgaisl(
  ObjFunc,
  N,
  p.range = NULL,
  popSize = 200,
  numIslands = 5,
  pcrossover = 0.95,
  pmutation = 0.15,
  pchangepoint = 0.01,
  minDist = 1,
  mmax = NULL,
  lmax = NULL,
  maxMig = 1000,
  maxgen = 50,
  maxconv = 100,
  option = "cp",
  monitoring = FALSE,
  parallel = FALSE,
  nCore = NULL,
  tol = 1e-05,
  seed = NULL,
  popInitialize = "random_population",
  suggestions = NULL,
  selection = "selection_linearrank",
  crossover = "uniformcrossover",
  mutation = "mutation",
  ...
)
}
\arguments{
\item{ObjFunc}{The fitness function to be minimized. Users can specify any R or Rcpp
function as the fitness function, setting the input as the potential solution to
the optimization problem and returning a numerical value as the output/fitness.
Depending on the user-specified chromosome representation, the optimization task
can be changepoint detection only or changepoint detection plus model order selection,
which can be specified via the \code{option} parameter. When
\code{option="both"}, the list \code{p.range} must be specified to give the range
of model orders.}

\item{N}{The sample size of the time series.}

\item{p.range}{Default is \code{NULL} for only changepoint detection. If
\code{p.range} is specified as a list object, which contains the range of
each model order parameters for order selection (integers). The number of
order parameters must be equal to the length of \code{p.range}.}

\item{popSize}{An integer representing the total number of individuals in each generation, which
equal to the number of islands multiplied by the size of each island (i.e., \code{popSize = number_of_islands Ã— Islandsize}).}

\item{numIslands}{An integer representing the number of islands (sub-populations).}

\item{pcrossover}{The probability that the crossover operator applies on two individual chromosomes.}

\item{pmutation}{The probability that the mutation operator applies on one individual chromosome.}

\item{pchangepoint}{The probability that a changepoint has occurred. User could change this probability based on domain knowledge and the time series length.}

\item{minDist}{The minimum length between two adjacent changepoints. Default value equals to one.}

\item{mmax}{The maximum possible number of changepoints in the data set. For a time series of length 1000 and we only want to detect the changepoint (\code{option="cp"}), the default value is 499. The suggested value should be based on the length of the time series. For instance, if a time series has length N, the recommended \code{mmax} should be \code{N/2-1}. It is suggested to add the number of model hyperparameters if both changepoint detection and model order selection tasks are of-interested simultaneously (\code{option="both"}).}

\item{lmax}{The maximum possible length of the chromosome representation. For a time series of length 1000 and we only want to detect the changepoint (\code{option="cp"}), the default value is 501. The suggested value should be based on the length of the time series. For instance, if a time series has length N, the recommended \code{lmax} should be \code{2+N/2-1}. It is suggested to add the number of model hyperparameters if both changepoint detection and model order selection tasks are of-interested simultaneously (\code{option="both"}).}

\item{maxMig}{An integer indicates the maximum number of migrations. After conducting \code{maxMig} migrations, the island-based GA algorithm stops.}

\item{maxgen}{An integer indicates the maximum number of generations that each island (subpopulation) undergoes before migration. It also determines the frequency of migration. The migration, as described earlier, will occur after \code{maxgen} generations for each sub-population (island).}

\item{maxconv}{An integer value is also used for algorithm termination. If the overall best-fitted value remains unchanged after \code{maxconv} consecutive migrations, the island-based GA algorithm will terminate.}

\item{option}{A character string: either \code{"cp"} for changepoint detection only, or \code{"both"} for changepoint detection and model order selection.}

\item{monitoring}{Logical. If \code{TRUE}, prints intermediate GA progress.}

\item{parallel}{A logical value \code{TRUE} or \code{FALSE}. Default value is FALSE. It indicates whether use multiple threads to parallel compute the individual fittness function values..}

\item{nCore}{An integer. Default value is \code{NULL}. It represents the number of cores used in parallel computing. It must be specified if setting \code{parallel=TRUE}.}

\item{tol}{An numerical value. Default is \code{1e-05}. The tolerance level for deciding GA to stop.}

\item{seed}{An integer. Default value \code{NULL}. An single integer allows function produce reproducible results.}

\item{popInitialize}{A function. It should be designed for initializing a population. The default population initialization is random initialization with some imposed constraints. See \code{\link{random_population}} for example. The function returned object is a matrix, \code{pop}. The users can specified their own \code{population} function. It could also be a matrix object, which contain the user specified chromosome. By default, each column represents one individual chromosome. See \code{\link{random_population}} for details.}

\item{suggestions}{A list object. Default value is \code{NULL}. Each element only needs to include the better or more reasonable results of the multiple changepoint locations. Having better \code{suggestions} can help GA converges faster.}

\item{selection}{A function. This GA operator can help select \code{mom} and \code{dad} from current generation population, where \code{dad} is set to have better fit (smaller fitness function values). The default for selection uses the linear rank selection method. See \code{\link{selection_linearrank}} for example. The function returned object is a list contain the chromosomes for \code{mom} and \code{dad}.}

\item{crossover}{A function. This GA operator can apply crossover to the chosen parents to produce child for next generation with specified probability. The default for crossover uses the uniform crossover method. See \code{\link{uniformcrossover}} for details in the default crossover operator. The function returned object is a vector contain the chromosomes for \code{child}.}

\item{mutation}{A function. This GA operator can apply mutation to the produced child with the specified probability \code{pmutation}. See \code{\link{mutation}} for details in the default mutation operator. The function returned object is a vector contain \code{child} chromosome representation.}

\item{...}{additional arguments that will be passed to the fitness function.}
}
\value{
Return an object class \code{cptgaisl-class}. See \code{\link{cptgaisl-class}} for a more detailed description.
}
\description{
Perform the modified island-based genetic algorithm (IslandGA) for multiple changepoint detection.
Minimization of an objective function using genetic algorithm (GA).
The algorithm can be run sequentially or in explicit parallelisation.
}
\examples{
\donttest{

N = 1000
XMatT = matrix(1, nrow=N, ncol=1)
Xt = ts.sim(beta=0.5, XMat=XMatT, sigma=1, phi=0.5, theta=NULL,
            Delta=c(2, -2), CpLoc=c(250, 750), seed=1234)

## Multiple changepoint detection without model order selection

# without suggestions
GAISL.res = cptgaisl(ObjFunc=ARIMA.BIC, N=N, XMat=XMatT, Xt=Xt)
summary(GAISL.res)
plot(GAISL.res, data=Xt)

# with suggestions
suggestions = list(NULL, 250, c(250, 500), c(250, 625), c(250, 500, 750))
GAISL.res = cptgaisl(ObjFunc=ARIMA.BIC, N=N, suggestions=suggestions, XMat=XMatT, Xt=Xt)
summary(GAISL.res)
plot(GAISL.res, data=Xt)


## Multiple changepoint detection with model order selection

p.range=list(ar=c(0,3), ma=c(0,3))

# without suggestions
GAISL.res = cptgaisl(ObjFunc=ARIMA.BIC.Order, N=N, p.range=p.range, 
            option = "both", XMat=XMatT, Xt=Xt)
summary(GAISL.res)
plot(GAISL.res, data=Xt)

# with suggestions
suggestions = list(NULL, 250, c(250, 500), c(250, 625), c(250, 500, 750))
GAISL.res = cptgaisl(ObjFunc=ARIMA.BIC.Order, N=N, p.range=p.range, 
            suggestions=suggestions, option = "both", XMat=XMatT, Xt=Xt)
summary(GAISL.res)
plot(GAISL.res, data=Xt)
}
}
